# Классы в Kotlin: От Основ до Продвинутых Концепций (Тема: Рик и Морти)

### Вступление: Сегодня у нас один из ключевых аспектов программирования и разработки, имя которому - Классы.

Вспомните наш мир. Он состоит из объектов, верно? У каждого объекта есть свои характеристики – цвет, размер, состояние. И каждый объект что-то умеет делать – машина ездит, дерево растёт, чашка держит кофе. Точно так же и в программировании. Мы постоянно работаем с "объектами" – будь то пользователь, элемент интерфейса, или, как в нашем случае, межпространственный путешественник, гений, уникум и алкоголик Рик Санчез и его нервный внук Морти, который вечно сохнет по Джессике.

Объектно-ориентированное программирование (ООП) – это подход, который позволяет нам моделировать реальный мир в коде, работая с этими самыми "объектами". И сердце ООП – это **классы**. Класс – это чертёж, шаблон, по которому мы создаём наши объекты. Он описывает, какие данные (свойства) будут у объекта и что он сможет делать (методы).

Сегодня мы погрузимся в мир классов Kotlin, используя любимых персонажей и безумные приключения из вселенной Рика и Морти, чтобы сделать наше путешествие по коду не только полезным, но и по-настоящему захватывающим! Приготовьтесь к межпространственным прыжкам по синтаксису и функционалу, ведь впереди – глубокое понимание того, как строится современное ПО.

Давайте начнем с самых азов, чтобы каждый смог уверенно шагнуть в это измерение программирования.

---

### Урок 1: Введение в Классы, Объекты и Экземпляры (Тема: Рик и Морти)

**Цель урока:**
* Понять, что такое класс и зачем он нужен.
* Объявить простой класс в Kotlin.
* Создать объекты (экземпляры) класса.
* Увидеть разницу между классом и объектом.

**Пояснение к коду:**
* `package lesson_01_intro`: Объявление пакета для организации кода.
* `class Character(val name: String, val species: String):`
    * Объявляем класс `Character`.
    * `(val name: String, val species: String)`: Это первичный конструктор. Он определяет, что каждый `Character` должен иметь свойства `name` (имя) и `species` (вид), оба типа `String`. `val` означает, что эти свойства только для чтения.
* `fun introduce()`: Метод класса `Character`. Он выводит информацию о персонаже, используя его свойства `name` и `species`.
* `fun catchphrase()`: Ещё один метод, демонстрирующий небольшую логику на основе свойства `name`.
* `fun main()`: Точка входа в программу.
* `val rick = Character("Рик Санчез", "Человек")`: Здесь мы создаем новый объект (или экземпляр) класса `Character`, передавая значения в его конструктор.
* `rick.name` и `rick.introduce()`: Это показывает, как получить доступ к свойствам объекта (`.name`) и вызвать его методы (`.introduce()`, `.catchphrase()`).

Мы определили наш первый класс и создали несколько персонажей из Рика и Морти. Каждый объект `Character` обладает своими уникальными данными (`name`, `species`) и способен выполнять действия (`introduce`, `catchphrase`).

---

### Урок 2: Свойства и Методы Классов

**Цель урока:**
* Понять разницу между изменяемыми (`var`) и неизменяемыми (`val`) свойствами.
* Узнать, как объявлять и использовать методы класса.
* Понять, как Kotlin генерирует геттеры и сеттеры автоматически.
* Научиться добавлять пользовательские геттеры и сеттеры.

**Пояснение к коду:**
* `class Character(val name: String, var dimension: String):`
* `val name: String`: Это неизменяемое свойство. После того как вы присвоили ему значение при создании объекта, вы не сможете его изменить. Kotlin автоматически генерирует для него только геттер (функцию для получения значения).
* `var dimension: String`: Это изменяемое свойство. Его значение можно менять в любое время после создания объекта. Kotlin автоматически генерирует для него и геттер, и сеттер (функцию для установки значения).
* `val origin: String = "Неизвестно":`
    * Пример неизменяемого свойства, инициализированного прямо в теле класса.
* `var currentLocation: String = "Земля C-137":`
    * Пример изменяемого свойства, также инициализированного в теле класса.
* `private var health: Int = 100:`
    * Пример приватного свойства. Модификатор `private` означает, что это свойство доступно только внутри самого класса `Character`. Извне объекта `Character` к `health` обратиться нельзя, что является частью инкапсуляции (мы подробнее поговорим об этом в одном из следующих уроков).
* `val status: String get() = if (health > 0) "Жив" else "Мертв":`
    * Это пример пользовательского геттера. Свойство `status` не хранит данные напрямую. Вместо этого, каждый раз, когда вы обращаетесь к `rick.status`, вызывается код в блоке `get()`, который вычисляет значение на основе текущего `health` объекта. Это полезно для свойств, которые являются производными от других данных.
* `fun changeLocation(newLocation: String):`
    * Простой метод, который принимает один аргумент `newLocation` и изменяет значение изменяемого свойства `currentLocation`.
* `fun takeDamage(amount: Int)` и `fun heal(amount: Int):`
    * Методы, которые демонстрируют, как внутренняя логика класса может изменять приватные свойства (`health`) и как это влияет на значения, возвращаемые пользовательскими геттерами (`status`). Обратите внимание на проверки на отрицательные значения и на лимиты здоровья (0-100), что делает методы более надежными.

Мы углубились в то, как свойства хранят данные, как методы выполняют действия, и как Kotlin облегчает работу с ними, автоматически генерируя геттеры и сеттеры, а также позволяя создавать пользовательские.

---

### Урок 3: Конструкторы и Инициализация Объектов

**Цель урока:**
* Понять роль конструкторов в создании объектов.
* Научиться использовать основной (`primary`) конструктор для инициализации свойств.
* Узнать, как объявлять дополнительные (`secondary`) конструкторы.
* Использовать блок `init` для выполнения логики инициализации.

**Пояснение к коду:**
* `class PortalGun(val maxCharges: Int):`
    * Это объявление класса `PortalGun` с основным конструктором. Параметр `maxCharges` в скобках является частью этого конструктора. `val` означает, что `maxCharges` автоматически становится неизменяемым свойством класса.
    * Основной конструктор — это самый компактный способ объявить конструктор и свойства одновременно.
* `var currentCharges: Int:`
    * Свойство, которое не инициализируется в основном конструкторе напрямую, но будет инициализировано в блоке `init`.
* `init { ... }:`
    * Блок инициализации. Этот блок выполняется сразу после вызова основного конструктора и перед тем, как объект будет полностью создан.
    * Он идеален для выполнения логики, которая необходима при создании каждого экземпляра класса, например, для валидации данных (`require(maxCharges > 0)`) или для установки начальных значений (`currentCharges = maxCharges`).
* `constructor() : this(50):`
    * Это дополнительный конструктор. Класс может иметь несколько таких конструкторов.
    * Ключевое слово `constructor` указывает на его объявление.
    * `: this(50)`: Это делегирование основному конструктору. Каждый дополнительный конструктор в Kotlin должен либо напрямую делегировать основному конструктору (как здесь), либо другому дополнительному конструктору, который в конечном итоге делегирует основному. Это гарантирует, что основной конструктор и блок `init` всегда будут выполнены. В данном случае, этот конструктор вызывает основной с `maxCharges = 50`.
* `constructor(isRandom: Boolean) : this(if (isRandom) Random.nextInt(10, 101) else 10):`
    * Еще один дополнительный конструктор, демонстрирующий более сложную логику делегирования, где значение для основного конструктора вычисляется.
* `class Rick(val portalGun: PortalGun):`
    * Этот класс демонстрирует, как объекты могут получать другие объекты в качестве зависимостей через свои конструкторы. Здесь Рик "получает" свою портальную пушку, что является примером внедрения зависимости (Dependency Injection).
* `try { ... } catch (e: IllegalArgumentException) { ... }:`
    * Блок `try-catch` демонстрирует, как перехватывать исключения, которые могут быть брошены из блока `init` (например, нашей `require` проверкой).

Теперь вы умеете создавать объекты с помощью различных конструкторов и контролировать процесс их инициализации. Это фундаментальные знания для построения гибких и надежных классов.

---

### Урок 4: Наследование

**Цель урока:**
* Понять, что такое наследование и зачем оно нужно.
* Узнать, как класс наследуется от другого класса в Kotlin.
* Использовать ключевые слова `open` и `override`.
* Понять, как вызывать методы родительского класса с помощью `super`.
* Различать базовые (родительские) и производные (дочерние) классы.

**Пояснение к коду:**
* `open class Creature(...):`
    * Ключевое слово `open` перед `class` крайне важно. По умолчанию, все классы в Kotlin являются `final`, то есть их нельзя наследовать. Чтобы разрешить наследование, нужно явно пометить класс как `open`.
    * Свойства (`sound`) и методы (`describe`) также должны быть помечены как `open`, если вы хотите, чтобы их можно было переопределить (`override`) в дочерних классах.
* `class Human(...) : Creature(name, dimension):`
    * Чтобы класс `Human` наследовал от `Creature`, используется двоеточие `:` с последующим именем родительского класса и вызовом его конструктора (`Creature(name, dimension)`).
    * `Human` принимает параметры `name`, `dimension` и `profession`. Первые два передаются в конструктор `Creature`.
* `override val sound: String = "Разговорная речь":`
    * Ключевое слово `override` используется для явного указания, что вы переопределяете свойство или метод, унаследованный от родительского класса. Это помогает компилятору проверять, что вы действительно переопределяете существующий элемент, а не создаете новый с таким же именем.
* `override fun describe() { super.describe(); ... }:`
    * Здесь мы переопределяем метод `describe()`.
    * `super.describe()`: Ключевое слово `super` позволяет вызвать реализацию метода (или свойство) из родительского класса. Это полезно, когда вы хотите расширить поведение родительского метода, а не полностью его заменить.
* `fun roam()` в `Creature` и `fun work() / fun abduct()` в дочерних классах:
    * Метод `roam()` определен в базовом классе `Creature` и автоматически наследуется `Human` и `Alien`. Они могут использовать его без дополнительного кода.
    * Методы `work()` в `Human` и `abduct()` в `Alien` являются специфичными для этих дочерних классов. Базовый класс `Creature` и другие дочерние классы не имеют к ним доступа.
* Демонстрация в `main`:
    * Мы создаем объекты разных типов (`Creature`, `Human`, `Alien`).
    * Вызываем их методы, демонстрируя, как `override` изменяет поведение.
    * Показываем, что объекты дочерних классов могут быть присвоены переменным типа родительского класса (это предвестник полиморфизма, который мы рассмотрим отдельно). Когда мы вызываем `creature.describe()` в цикле, Kotlin вызывает правильную (переопределенную) версию метода для каждого объекта.

---

### Урок 5: Модификаторы Видимости и Инкапсуляция

**Цель урока:**
* Понять концепцию инкапсуляции.
* Изучить основные модификаторы видимости в Kotlin: `public`, `private`, `protected`, `internal`.
* Научиться применять эти модификаторы к классам, свойствам и методам.
* Понять, как модификаторы видимости влияют на доступ к членам класса.

**Пояснение к коду:**
* `public` (по умолчанию):
    * Это самый широкий уровень видимости. Члены, помеченные как `public` (или без модификатора, так как это поведение по умолчанию), доступны из любого места, где виден класс.
    * Пример: `PublicCharacter`. Его свойство `name` и метод `greet()` доступны в `main` напрямую.
* `private`:
    * Самый строгий уровень видимости. Члены, помеченные как `private`, видны только внутри того класса, в котором они объявлены. Они не видны даже для подклассов.
    * Пример: `PrivateLab`. `secretFormula` и `activateSelfDestruct()` доступны только внутри методов `PrivateLab`, таких как `revealSecret()`. Вы не можете обратиться к ним напрямую из `main()`. Это ключевой аспект инкапсуляции: внутренняя логика и данные скрыты.
* `protected`:
    * Этот модификатор является компромиссом между `private` и `public`. Члены, помеченные как `protected`, доступны внутри класса, где они объявлены, и во всех его подклассах. Однако они не доступны извне иерархии наследования.
    * Пример: `AlienBeing` и `AdvancedAlien`. `secretPower` и `displaySecretPower()` в `AlienBeing` доступны для `AdvancedAlien` (его подкласса), но не для `main()`.
* `internal`:
    * Этот модификатор специфичен для Kotlin и очень полезен в крупных проектах, состоящих из нескольких модулей (например, разных модулей Gradle в Android-приложении или разных JAR-файлов в большой Java/Kotlin системе).
    * Члены, помеченные как `internal`, доступны в любом месте внутри того же модуля, где они объявлены. Но они не доступны из других модулей.
    * В нашем простом проекте, где весь код находится в одном модуле, `internal` ведет себя почти как `public`. Его истинная польза проявляется при модульном дизайне.

Инкапсуляция — это не просто сокрытие данных, это предоставление четкого, контролируемого интерфейса для взаимодействия с объектом. Мы делаем некоторые вещи `private` или `protected` не потому, что хотим их спрятать, а потому что это внутренняя деталь реализации, которая не должна быть изменена извне, чтобы не нарушить целостность объекта.
На этом уроке мы завершили тему инкапсуляции и модификаторов видимости. Теперь вы понимаете, как контролировать доступ к вашему коду.

---

### Урок 6: Полиморфизм и Интерфейсы

Сегодня у нас на повестке дня полиморфизм и интерфейсы — мощные концепции в ООП, которые позволяют писать более гибкий, расширяемый и легко поддерживаемый код.
Полиморфизм (от греч. "много форм") позволяет объектам разных классов, имеющих общего предка (базовый класс или интерфейс), обрабатываться как объекты этого общего типа. А интерфейсы определяют контракт, которому должен соответствовать класс, но не предоставляют реализации.
Мы продолжим с Риком и Морти, демонстрируя, как различные сущности могут выполнять схожие действия, при этом сохраняя свою уникальность.

**Цель урока:**
* Понять концепцию полиморфизма и его применение.
* Узнать, что такое интерфейс и зачем он нужен.
* Научиться объявлять интерфейсы в Kotlin.
* Использовать интерфейсы для обеспечения общего поведения у разных классов.
* Увидеть, как абстрактные классы соотносятся с интерфейсами.

**Пояснение к коду:**
* `interface Communicator { ... }:`
    * Интерфейс объявляется с ключевым словом `interface`.
    * Он содержит только объявления методов (`sendMessage`, `receiveMessage`), но не их реализацию.
    * Классы, которые хотят "подписать контракт" этого интерфейса, должны реализовать (`provide an implementation for`) все его методы.
* `abstract class CosmicBeing(...) { abstract fun performCosmicDuty() ... }:`
    * Абстрактный класс объявляется с ключевым словом `abstract`.
    * Он не может быть создан напрямую (`val myBeing = CosmicBeing(...)` вызовет ошибку).
    * Он может содержать как абстрактные методы (`abstract fun performCosmicDuty()`), которые не имеют реализации и должны быть переопределены в подклассах, так и реализованные методы (`fun describeExistence()`).
    * В отличие от интерфейсов, класс может наследовать только от одного абстрактного класса (единоличное наследование реализации).
* `class Rick(...) : CosmicBeing(...), Communicator { ... }:`
    * Класс `Rick` наследуется от `CosmicBeing` (что означает, он должен реализовать `performCosmicDuty()`) и реализует интерфейс `Communicator` (что означает, он должен реализовать `sendMessage()` и `receiveMessage()`).
    * В Kotlin класс может наследовать только от одного класса, но может реализовывать много интерфейсов.
* Полиморфизм:
    * Пример 1 (с интерфейсом `Communicator`):
        * Мы создаем `List<Communicator>`. В этот список мы можем добавить объекты `Rick` и `Morty`, потому что оба они реализуют интерфейс `Communicator`.
        * Когда мы перебираем этот список и вызываем `comm.sendMessage(...)` или `comm.receiveMessage()`, Kotlin полиморфно вызывает правильную реализацию метода для каждого объекта (ту, что определена в `Rick` или `Morty`).
        * При этом, когда переменная имеет тип `Communicator`, мы можем вызывать только те методы, которые определены в интерфейсе `Communicator`. Мы не можем вызвать `inventGadget()` или `panic()` напрямую через переменную типа `Communicator`, потому что эти методы специфичны для `Rick` и `Morty` и не являются частью "контракта" `Communicator`.
    * Пример 2 (с абстрактным классом `CosmicBeing`):
        * Аналогично, `List<CosmicBeing>` может содержать `Rick` и `Morty`, так как они его подклассы.
        * Вызов `being.performCosmicDuty()` также демонстрирует полиморфизм, вызывая специфичную реализацию для каждого типа.
* `CouncilOfRicks:`
    * Этот класс демонстрирует, как полиморфизм позволяет нам работать с коллекцией объектов одного базового типа (`Rick` в данном случае), хотя каждый `Rick` может иметь свои особенности.

---

### Урок 7: Специальные Классы Kotlin: Data, Sealed, Object

Теперь мы переходим к одной из самых интересных и мощных особенностей Kotlin — его специальным типам классов. Эти классы были разработаны для решения конкретных, часто встречающихся задач и значительно упрощают разработку, сокращая объем шаблонного кода.
Мы рассмотрим Data-классы, Sealed-классы и Object-классы, продолжая использовать тему Рика и Морти для примеров.

**Цель урока:**
* Понять, что такое `data class` и когда его использовать.
* Узнать о преимуществах `data class` (автоматические `equals`, `hashCode`, `toString`, `copy`, `componentN`).
* Изучить концепцию `sealed class` для создания иерархий с ограниченным набором подклассов.
* Понять, когда использовать `object` для синглтонов и именованных объектов.
* Узнать про `companion object` для статических членов класса.

**Пояснение к коду:**
* `data class Episode(...):`
    * Назначение: Идеально подходит для классов, основная цель которых — хранить данные.
    * Автоматические функции: Компилятор Kotlin автоматически генерирует реализации для `equals()`, `hashCode()`, `toString()`, `copy()` и `componentN()` (для деструктуризации). Это избавляет от огромного количества шаблонного кода, который пришлось бы писать вручную в Java.
    * Пример использования: Сравнение двух `Episode` объектов (`firstEpisode == secondEpisode`) происходит по значению их свойств, а не по ссылке. `toString()` дает осмысленный вывод. `copy()` позволяет легко создавать новый объект с измененными некоторыми свойствами, не затрагивая оригинал. Деструктуризация (`val (s, epNum, title, date) = firstEpisode`) позволяет легко извлекать свойства в отдельные переменные.
* `sealed class GalacticEvent { ... }:`
    * Назначение: Используется для создания закрытых иерархий классов, где все возможные подклассы известны и объявлены внутри этого `sealed class` (или в том же файле).
    * Преимущество с `when`: Главное преимущество `sealed class` проявляется с выражением `when`. Если вы используете `when` для обработки всех возможных подклассов `sealed class`, компилятор может проверить, что вы охватили все случаи. Если вы добавите новый подкласс, компилятор выдаст ошибку, пока вы не обновите все `when` выражения, использующие этот `sealed class`. Это обеспечивает исчерпывающее (`exhaustive`) сопоставление с образцом (`pattern matching`).
    * Пример: `GalacticEvent` может быть `PortalAnomaly`, `UniversalThreat` или `AlienInvasion`. Функция `processGalacticEvent` безопасно обрабатывает все эти варианты.
* `object InterdimensionalCouncil { ... }:`
    * Назначение: Объектный класс (`object`) — это способ объявить синглтон (одиночку) в Kotlin. Синглтон — это класс, у которого может быть только один экземпляр.
    * Использование: Вы обращаетесь к членам объектного класса напрямую по его имени (`InterdimensionalCouncil.addRick()`), без создания экземпляра с `new`.
    * Применение: Идеально для утилит, конфигураций, менеджеров состояния или любого объекта, который логически должен существовать в единственном экземпляре в приложении.
* `companion object Factory { ... }` в `class SpaceShip:`
    * Назначение: Сопутствующий объект (`companion object`) — это одиночный объект, который ассоциирован с классом, но не является его экземпляром. Это позволяет создавать "статические" члены (методы и свойства класса), похожие на `static` в Java, но реализованные как часть объектной модели Kotlin.
    * Использование: Доступ к членам сопутствующего объекта осуществляется через имя класса (`SpaceShip.createDefaultShip()`). Имя `Factory` для сопутствующего объекта опционально, по умолчанию оно `Companion`.
    * `const val`: Позволяет объявлять константы времени компиляции. Они должны быть примитивного типа или `String` и быть инициализированы литералом.

Эти специальные классы значительно упрощают разработку, предоставляя компактные и безопасные способы определения и использования классов для специфических сценариев.

---

### Урок 8: Функции Расширения (Extension Functions)

Отлично, движемся к одной из самых элегантных и мощных особенностей Kotlin — функциям расширения. Эта фича позволяет добавлять новые функции к существующим классам, даже если у вас нет доступа к их исходному коду. Это особенно полезно для работы с библиотечными классами или для создания более читаемого, "текучего" API.
Мы снова будем использовать примеры, связанные с Риком и Морти.

**Цель урока:**
* Понять, что такое функция расширения и зачем она нужна.
* Научиться объявлять функции расширения для существующих классов.
* Узнать, как использовать функции расширения для повышения читаемости кода.
* Увидеть, как функции расширения отличаются от обычных методов класса.

**Пояснение к коду:**
* Объявление функции расширения:
    * Синтаксис: `fun ReceiverType.functionName(parameters): ReturnType { ... }`
    * `ReceiverType`: Это тип, который мы хотим "расширить". В нашем случае это `String`, `Character`, `List<Episode>`.
    * `this`: Внутри функции расширения ключевое слово `this` ссылается на объект, для которого эта функция была вызвана. Например, в `String.toRickAndMortyCaps()`, `this` будет экземпляром `String` ("Рик: Вубба Лубба Даб Даб").
* `fun String.toRickAndMortyCaps(): String:`
    * Мы добавили метод `toRickAndMortyCaps()` к стандартному классу `String`. Теперь любая строка в нашей программе может вызвать этот метод, как будто он был изначально частью класса `String`.
    * Это позволяет писать более читаемый код, например: `myString.toRickAndMortyCaps()`.
* `fun Character.travelToDimension(newDimension: String):`
    * Мы "расширили" наш собственный класс `Character` (который был определен в `lesson_01_intro`) новым поведением, не изменяя его исходный код. Это демонстрирует мощь функций расширения для добавления функциональности к уже существующим классам, даже если они из другой части вашего проекта или из сторонней библиотеки.
* `fun List<Episode>.printAllTitles():`
    * Пример расширения для обобщенного типа (`List<Episode>`). Мы добавили полезный метод для печати информации о коллекции эпизодов. Это показывает, как можно создавать удобные утилитарные функции для коллекций.
* Как это работает "под капотом":
    * Функции расширения не изменяют сам класс. Они не добавляют новый метод в таблицу виртуальных методов класса.
    * Компилятор Kotlin преобразует вызов `someString.toRickAndMortyCaps()` в статический вызов функции `toRickAndMortyCaps(someString)`. То есть, по сути, функция расширения — это синтаксический сахар для статических утилитарных функций, где первый аргумент является "принимающим" объектом.
    * Это означает, что функции расширения не могут получить доступ к `private` или `protected` членам класса, который они расширяют, поскольку они не являются частью этого класса.

Функции расширения — это мощный инструмент для создания чистого и идиоматического Kotlin-кода. Они помогают избегать создания множества утилитных классов с статическими методами и делают ваш код более выразительным.

---

### Урок 9: Вложенные и Внутренние Классы

Отлично, вот и последний урок в нашей структуре по классам! Сегодня мы разберем вложенные (`nested`) и внутренние (`inner`) классы в Kotlin. Это специальные типы классов, которые определяются внутри других классов. Они полезны для лучшей организации кода и инкапсуляции, но имеют важные различия в отношении доступа к членам внешнего класса.
Продолжим тему Рика и Морти.

**Цель урока:**
* Понять, что такое вложенный класс (`nested class`) и его особенности.
* Узнать, что такое внутренний класс (`inner class`) и чем он отличается от вложенного.
* Понять, когда использовать каждый тип вложенности.
* Увидеть, как они влияют на доступ к членам внешнего класса.

**Пояснение к коду:**
* Внешний класс (`Spaceship`):
    * Это обычный класс, внутри которого мы будем определять вложенные и внутренние классы. У него есть свойства (`name`, `capacity`) и метод (`displayInfo`).
* Вложенный класс (`Nested Class` - `NavigationSystem`):
    * Объявляется как обычный класс внутри другого, но без ключевого слова `inner`.
    * Отличия:
        * Нет неявной ссылки на внешний класс: `NavigationSystem` не имеет доступа к членам `Spaceship` (таким как `name` или `capacity`). Это видно из закомментированной строки `// println("Прокладываю курс для ${this@Spaceship.name} к $targetDimension.")`, которая вызовет ошибку компиляции.
        * Создание экземпляра: Экземпляр вложенного класса можно создать напрямую, используя имя внешнего класса как префикс (`Spaceship.NavigationSystem(...)`). Вам не нужен экземпляр `Spaceship` для создания `NavigationSystem`.
    * Назначение: Используется для логической группировки классов, когда внутренний класс не зависит от состояния внешнего. Например, если `NavigationSystem` может использоваться разными кораблями или вообще отдельно от них, но логически связан со `Spaceship`.
* Внутренний класс (`Inner Class` - `PassengerBay`):
    * Объявляется с ключевым словом `inner`.
    * Отличия:
        * Есть неявная ссылка на внешний класс: `PassengerBay` имеет доступ к членам `Spaceship`, включая приватные свойства (например, `capacity` и `name`).
        * Создание экземпляра: Для создания экземпляра `inner` класса **обязательно** нужен экземпляр внешнего класса (`burpship.PassengerBay()`). Экземпляр `PassengerBay` всегда "принадлежит" конкретному экземпляру `Spaceship`.
        * `this@ClassName`: Если внутри `inner` класса нужно явно сослаться на экземпляр внешнего класса, используйте `this@ClassName` (например, `this@Spaceship.name`).
    * Назначение: Используется, когда внутренний класс тесно связан с состоянием внешнего класса и должен иметь доступ к его членам. Например, `PassengerBay` логически является частью конкретного `Spaceship` и оперирует его вместимостью.

На этом наш урок по классам в Kotlin завершен! Вы прошли путь от базовых определений до таких продвинутых концепций, как полиморфизм, интерфейсы, специальные типы классов и вложенность.

---

### Урок 10: Утилиты и Расширения – Где Разместить Общий Код?

Привет! Наконец-то, мы добрались до важного вопроса, который постоянно возникает у технарей: "Куда девать общий код?". Мы создали много всего, и вполне логично, что ты спросил про `Utils.kt`. Это была моя ошибка, что я не прояснил этот момент раньше.
В Kotlin нет такого понятия, как статический класс-утилита в том виде, в каком он есть, например, в Java (где `Math.random()` вызывается из статического класса `Math`). Вместо этого, Kotlin предлагает несколько более "котлиновских" подходов, которые делают код чище и гибче.
Давай рассмотрим, как мы будем работать с файлом `src/main/kotlin/common/Utils.kt` (или лучше назвать его `src/main/kotlin/common/CommonExtensions.kt`, так как мы будем использовать функции расширения) и почему он так важен.

**Цель урока:**
* Понять, зачем нужны общие утилитарные функции и расширения.
* Узнать, как объявлять функции верхнего уровня (`Top-Level Functions`).
* Закрепить понимание функций расширения как основного инструмента для утилит.
* Понять, когда использовать объектные классы (`object`) для общих утилит.
* Правильно организовать общий код в проекте.

**Пояснение к коду и его использованию:**
* `package common:`
    * Этот файл объявлен в пакете `common`. Это означает, что для использования его содержимого в других файлах (например, в `App.kt` каждого урока), нам нужно будет добавить `import common.*` или конкретные импорты, например, `import common.logWithTag`.
* `fun String.logWithTag(tag: String = "КОД УРОКА")` (Функция расширения):
    * Это наш основной подход к созданию утилит. Вместо `Utils.log("My message", "TAG")`, мы можем писать `"My message".logWithTag("TAG")`. Это более читабельно и идиоматично для Kotlin.
    * Позволяет добавлять новые "методы" к существующим типам. Мы уже видели это в Уроке 8.
    * Применение: Идеально для функций, которые оперируют данными конкретного типа.
* `fun printSectionHeader(title: String)` (Функция верхнего уровня):
    * Это функция, которая не привязана ни к какому классу. Она находится прямо "наверху" файла.
    * Применение: Используется для простых, глобально доступных утилит, которые не имеют состояния и не оперируют экземпляром конкретного класса. В нашем случае, это отличный способ выводить заголовки уроков, не повторяя код.
* `object DimensionUtils { ... }` (Объект-утилита / Синглтон):
    * Иногда утилитарные функции должны иметь какое-то состояние (например, список зарегистрированных измерений) или быть логически сгруппированы вместе. В таких случаях `object` подходит идеально. Это синглтон, то есть будет существовать только один экземпляр `DimensionUtils` в течение работы программы.
    * Применение: Для сложных утилит, которые нуждаются в внутреннем состоянии или представляют собой логическую группу связанных функций (например, утилиты для работы с файлами, с сетью, с базами данных и т.д.).

---

P.S. Данный урок был вдохновлен мультсериалом Рик и Морти, а также далекими воспоминаниями курса по Java с ресурса Java Rush и их подходом с аналогиями о космосе, путешествиях и роботах.

С уважением Дэниел.